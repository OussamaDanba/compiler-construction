\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[nounderscore]{syntax}

\title{Compiler Construction report}
\author{Oussama Danba}
\date{\today}

\begin{document}

\maketitle

% given grammar, note that <char> was added for completeness
\renewcommand{\syntleft}{$\langle$\normalfont\ttfamily}
\setlength{\grammarindent}{2cm}
\setlength{\grammarparsep}{0cm}
\begin{grammar}
<SPL> = <Decl>+

<Decl> = <VarDecl> \\| <FunDecl>

<VarDecl> = ('\textbf{var}' | <Type>) <id> '=' <Exp> ';'

<FunDecl> = <id> '(' [ <FArgs> ] ')' [ '::' <FunType> ] '\{' <VarDecl>* <Stmt>+ '\}'

<RetType> = <Type> \\| '\textbf{Void}'

<FunType> = [ <FTypes> ] '$\rightarrow$' <RetType>

<FTypes> = <Type> [ <FTypes> ]

<Type> = <BasicType> \\| '(' <Type> ',' <Type> ')' \\| '[' <Type> ']' \\| <id>

<BasicType> = '\textbf{Int}' \\| '\textbf{Bool}' \\| '\textbf{Char}'

<FArgs> = [ <FArgs> ',' ] <id>

<Stmt> = '\textbf{if}' '(' <Exp> ')' '\{' <Stmt>* '\}' [ '\textbf{else}' '\{' <Stmt>* '\}' ] \\| '\textbf{while}' '(' <Exp> ')' '\{' <Stmt>* '\}' \\| <id> <Field> '=' <Exp> ';' \\| <FunCall> ';' \\| '\textbf{return}' [ <Exp> ] ';'

<Exp> = <id> <Field> \\| <Exp> <Op2> <Exp> \\| <Op1> <Exp> \\| <int> \\| <char> \\| '\textbf{False}' \\| '\textbf{True}' \\| '(' <Exp> ')' \\| <FunCall> \\| '[]' \\| '(' <Exp> ',' <Exp> ')'

<Field> = [ <Field> ( '.' '\textbf{hd}' | '.' '\textbf{tl}' | '.' '\textbf{fst}' | '.' '\textbf{snd}' ) ]

<FunCall> = <id> '(' [ <ActArgs> ] ')'

<ActArgs> = <Exp> [ ',' <ActArgs> ]

<Op2> = '+' | '-' | '*' | '/' | '\%' | '==' | '\textless' | '\textgreater' | '\textless=' | '\textgreater=' | '!=' | '\&\&' | '||' | ':'

<Op1> = '!' | '-'

<int> = [ '-' ] digit+

<char> = ' alpha '

<id> = alpha ( '\_' | alphaNum)*
\end{grammar}

% grammar that the parser initially parsed (changed during semantic analysis)
% BasicType moved into Type for easiness
% FArgs turned around to remove left recursion. (result is the same)
% Field split into Field and Field2 to remove left recursion.
% Exp split up into parts to take operator precedence into account. <Exp> <Op2> <Exp> is no longer needed because it is encoded through the other means.
\begin{grammar}
<SPL> = <Decl>+

<Decl> = <VarDecl> \\| <FunDecl>

<VarDecl> = ('\textbf{var}' | <Type>) <id> '=' <Exp> ';'

<FunDecl> = <id> '(' [ <FArgs> ] ')' [ '::' <FunType> ] '\{' <VarDecl>* <Stmt>+ '\}'

<RetType> = <Type> \\| '\textbf{Void}'

<FunType> = [ <FTypes> ] '$\rightarrow$' <RetType>

<FTypes> = <Type> [ <FTypes> ]

<Type> = '\textbf{Int}' \\| '\textbf{Bool}' \\| '\textbf{Char}' \\| '(' <Type> ',' <Type> ')' \\| '[' <Type> ']' \\| <id>

<FArgs> = <id> [ <FArgs> ',' ]

<Stmt> = '\textbf{if}' '(' <Exp> ')' '\{' <Stmt>* '\}' [ '\textbf{else}' '\{' <Stmt>* '\}' ] \\| '\textbf{while}' '(' <Exp> ')' '\{' <Stmt>* '\}' \\| <id> <Field> '=' <Exp> ';' \\| <FunCall> ';' \\| '\textbf{return}' [ <Exp> ] ';'

<Exp> = <Exp2> [ '||' <Exp> ]

<Exp2> = <Exp3> [ '\&\&' <Exp2> ]

<Exp3> = <Exp4> [ ':' <Exp3> ]

<Exp4> = <Exp5> [ ( '==' | '\textless' | '\textgreater' | '\textless=' | '\textgreater=' | '!=' ) <Exp4> ]

<Exp5> = <Exp6> [ ( '+' | '-' ) <Exp5> ]

<Exp6> = <Exp7> [ ( '*' | '/' ) <Exp6> ]

<Exp7> = <Exp8> [ '\%' <Exp7> ]

<Exp8> = <id> <Field> \\| <Op1> <Exp> \\| <int> \\| <char> \\| '\textbf{False}' \\| '\textbf{True}' \\| '(' <Exp> ')' \\| <FunCall> \\| '[]' \\| '(' <Exp> ',' <Exp> ')'

<Field> = <Field2>*

<Field2> = '.' '\textbf{hd}' | '.' '\textbf{tl}' | '.' '\textbf{fst}' | '.' '\textbf{snd}'

<FunCall> = <id> '(' [ <ActArgs> ] ')'

<ActArgs> = <Exp> [ ',' <ActArgs> ]

<Op1> = '!' | '-'

<int> = [ '-' ] digit+

<char> = ' alpha '

<id> = alpha ( '\_' | alphaNum)*
\end{grammar}

\section{Scanning and Parsing}
\subsection{Scanner}

\subsection{Parser}

\section{Semantic Analysis}
% Doing monomorphic type checking
% Grammar parsed when starting semantic analysis
% var keyword removed
% FunType can no longer be optional
% no identifier allowed in Type

% note that [Int] x = []; is considered a type error since there no way to add to a list
\begin{grammar}
<SPL> = <Decl>+

<Decl> = <VarDecl> \\| <FunDecl>

<VarDecl> = <Type> <id> '=' <Exp> ';'

<FunDecl> = <id> '(' [ <FArgs> ] ')' '::' <FunType> '\{' <VarDecl>* <Stmt>+ '\}'

<RetType> = <Type> \\| '\textbf{Void}'

<FunType> = [ <FTypes> ] '$\rightarrow$' <RetType>

<FTypes> = <Type> [ <FTypes> ]

<Type> = '\textbf{Int}' \\| '\textbf{Bool}' \\| '\textbf{Char}' \\| '(' <Type> ',' <Type> ')' \\| '[' <Type> ']'

<FArgs> = <id> [ <FArgs> ',' ]

<Stmt> = '\textbf{if}' '(' <Exp> ')' '\{' <Stmt>* '\}' [ '\textbf{else}' '\{' <Stmt>* '\}' ] \\| '\textbf{while}' '(' <Exp> ')' '\{' <Stmt>* '\}' \\| <id> <Field> '=' <Exp> ';' \\| <FunCall> ';' \\| '\textbf{return}' [ <Exp> ] ';'

<Exp> = <Exp2> [ '||' <Exp> ]

<Exp2> = <Exp3> [ '\&\&' <Exp2> ]

<Exp3> = <Exp4> [ ':' <Exp3> ]

<Exp4> = <Exp5> [ ( '==' | '\textless' | '\textgreater' | '\textless=' | '\textgreater=' | '!=' ) <Exp4> ]

<Exp5> = <Exp6> [ ( '+' | '-' ) <Exp5> ]

<Exp6> = <Exp7> [ ( '*' | '/' ) <Exp6> ]

<Exp7> = <Exp8> [ '\%' <Exp7> ]

<Exp8> = <id> <Field> \\| <Op1> <Exp> \\| <int> \\| <char> \\| '\textbf{False}' \\| '\textbf{True}' \\| '(' <Exp> ')' \\| <FunCall> \\| '[]' \\| '(' <Exp> ',' <Exp> ')'

<Field> = <Field2>*

<Field2> = '.' '\textbf{hd}' | '.' '\textbf{tl}' | '.' '\textbf{fst}' | '.' '\textbf{snd}'

<FunCall> = <id> '(' [ <ActArgs> ] ')'

<ActArgs> = <Exp> [ ',' <ActArgs> ]

<Op1> = '!' | '-'

<int> = [ '-' ] digit+

<char> = ' alpha '

<id> = alpha ( '\_' | alphaNum)*
\end{grammar}

% first we collect all function declarations and check those (num args matches etc.) and enter them into the type environment
% then we check all global variables. We can do this now since we know the function declarations.
% then we check all functions. We can do this since we know all global variables.
% functions and variables go into the same type environment but we use a bool to track whether it is a function or a variable.

\section{Code Generation}

\end{document}
